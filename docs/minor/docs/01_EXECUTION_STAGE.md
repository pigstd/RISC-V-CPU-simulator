# æ‰§è¡Œé˜¶æ®µ (Execution Stage) è¯¦ç»†æ–‡æ¡£

## ğŸ“Œ æ¦‚è¿°

æ‰§è¡Œé˜¶æ®µæ˜¯ Minor-CPU æµæ°´çº¿çš„æ ¸å¿ƒè®¡ç®—å•å…ƒï¼Œè´Ÿè´£ä»¥ä¸‹å…³é”®ä»»åŠ¡ï¼š

1. **æ•°æ®å†’é™©æ£€æµ‹ä¸å¤„ç†** - æ£€æŸ¥æ“ä½œæ•°æ˜¯å¦å¯ç”¨
2. **æ“ä½œæ•°è·å–** - ä»å¯„å­˜å™¨å †æˆ–æ—è·¯ç½‘ç»œè·å–æ•°æ®
3. **ALU è¿ç®—** - æ‰§è¡Œç®—æœ¯é€»è¾‘è¿ç®—
4. **åˆ†æ”¯åˆ¤æ–­** - è®¡ç®—åˆ†æ”¯æ¡ä»¶å’Œç›®æ ‡åœ°å€
5. **è®¿å­˜åœ°å€è®¡ç®—** - ä¸º load/store æŒ‡ä»¤è®¡ç®—å†…å­˜åœ°å€

---

## ğŸ“‚ æºæ–‡ä»¶ä½ç½®

æ‰§è¡Œé˜¶æ®µçš„ä»£ç ä¸»è¦åœ¨ `main.py` ä¸­çš„ `Execution` ç±»ä¸­å®ç°ã€‚

---

## ğŸ—ï¸ æ¨¡å—å®šä¹‰

```python
class Execution(Module):

    def __init__(self):
        super().__init__(
            ports={
                'signals': Port(deocder_signals),  # æ¥è‡ªè¯‘ç å™¨çš„æ§åˆ¶ä¿¡å·
                'fetch_addr': Port(Bits(32)),      # å½“å‰æŒ‡ä»¤çš„ PC åœ°å€
            })
        self.name = "E"
```

### è¾“å…¥ç«¯å£è¯´æ˜

| ç«¯å£å       | ç±»å‹                       | è¯´æ˜                                                                         |
| ------------ | -------------------------- | ---------------------------------------------------------------------------- |
| `signals`    | `deocder_signals` (Record) | åŒ…å«æ‰€æœ‰è¯‘ç åçš„æ§åˆ¶ä¿¡å·ï¼Œå¦‚ ALU æ“ä½œç±»å‹ã€æ“ä½œæ•°æ¥æºã€åˆ†æ”¯æ ‡å¿—ç­‰            |
| `fetch_addr` | `Bits(32)`                 | å½“å‰æ­£åœ¨æ‰§è¡Œçš„æŒ‡ä»¤çš„ç¨‹åºè®¡æ•°å™¨å€¼ï¼Œç”¨äºåˆ†æ”¯ç›®æ ‡è®¡ç®—å’Œ `jal`/`jalr` çš„é“¾æ¥åœ°å€ |

### å¤–éƒ¨ä¾èµ–

æ‰§è¡Œæ¨¡å—éœ€è¦è®¿é—®ä»¥ä¸‹å¤–éƒ¨èµ„æºï¼š

| èµ„æº                   | ç±»å‹                     | ç”¨é€”               |
| ---------------------- | ------------------------ | ------------------ |
| `rf`                   | `RegArray(Bits(32), 32)` | 32 ä¸ªé€šç”¨å¯„å­˜å™¨    |
| `exec_bypass_reg/data` | `RegArray`               | æ‰§è¡Œé˜¶æ®µæ—è·¯å¯„å­˜å™¨ |
| `mem_bypass_reg/data`  | `RegArray`               | è®¿å­˜é˜¶æ®µæ—è·¯å¯„å­˜å™¨ |
| `wb_bypass_reg/data`   | `RegArray`               | å†™å›é˜¶æ®µæ—è·¯å¯„å­˜å™¨ |
| `reg_onwrite`          | `RegArray(Bits(32), 1)`  | å¯„å­˜å™¨å ç”¨ä½å›¾     |
| `csr_f`                | `RegArray(Bits(32), 16)` | CSR å¯„å­˜å™¨æ–‡ä»¶     |

---

## ğŸ”„ æ‰§è¡Œæµç¨‹è¯¦è§£

### ç¬¬ä¸€æ­¥ï¼šæ•°æ®å†’é™©æ£€æµ‹

æ•°æ®å†’é™©ï¼ˆData Hazardï¼‰å‘ç”Ÿåœ¨å½“å‰æŒ‡ä»¤éœ€è¦ä½¿ç”¨å°šæœªå†™å›çš„å¯„å­˜å™¨å€¼æ—¶ã€‚Minor-CPU ä½¿ç”¨ä»¥ä¸‹æœºåˆ¶æ£€æµ‹å’Œå¤„ç†è¿™ç§æƒ…å†µï¼š

#### 1.1 æ£€æµ‹é€»è¾‘

```python
signals = self.signals.peek()  # å·çœ‹ä¿¡å·ï¼Œä¸æ¶ˆè€—

rs1 = signals.rs1  # æºå¯„å­˜å™¨1
rs2 = signals.rs2  # æºå¯„å­˜å™¨2
rd = signals.rd    # ç›®æ ‡å¯„å­˜å™¨

on_write = reg_onwrite[0]  # å½“å‰è¢«å ç”¨çš„å¯„å­˜å™¨ä½å›¾
```

**`reg_onwrite` ä½å›¾è¯´æ˜**ï¼š

- è¿™æ˜¯ä¸€ä¸ª 32 ä½çš„ä½å›¾ï¼Œæ¯ä¸€ä½å¯¹åº”ä¸€ä¸ªå¯„å­˜å™¨
- å¦‚æœç¬¬ N ä½ä¸º 1ï¼Œè¡¨ç¤ºå¯„å­˜å™¨ xN æ­£åœ¨è¢«å‰åºæŒ‡ä»¤å†™å…¥
- æŒ‡ä»¤è¿›å…¥æ‰§è¡Œé˜¶æ®µæ—¶è®¾ç½®å¯¹åº”ä½ï¼Œå†™å›å®Œæˆæ—¶æ¸…é™¤

#### 1.2 åˆ¤æ–­ rs1 æ˜¯å¦å¯ç”¨

```python
a_valid = (exec_bypass_reg[0] == rs1) |    # æ¡ä»¶1: æ‰§è¡Œé˜¶æ®µæ—è·¯å¯ç”¨
          (mem_bypass_reg[0] == rs1) |     # æ¡ä»¶2: è®¿å­˜é˜¶æ®µæ—è·¯å¯ç”¨
          ~signals.rs1_valid |              # æ¡ä»¶3: å½“å‰æŒ‡ä»¤ä¸éœ€è¦ rs1
          (~(on_write >> rs1))[0:0]         # æ¡ä»¶4: rs1 æ²¡æœ‰è¢«å ç”¨

# å¦‚æœä»¥ä¸Šéƒ½ä¸æ»¡è¶³ï¼Œå†æ£€æŸ¥å†™å›é˜¶æ®µæ—è·¯
a_valid_true = a_valid.select(Bits(1)(1), (wb_bypass_reg[0] == rs1).bitcast(Bits(1)))
```

**è¯¦ç»†è§£é‡Š**ï¼š

1. **æ‰§è¡Œé˜¶æ®µæ—è·¯** (`exec_bypass_reg[0] == rs1`)

   - å¦‚æœä¸Šä¸€æ¡æŒ‡ä»¤çš„ç›®æ ‡å¯„å­˜å™¨å°±æ˜¯æˆ‘ä»¬éœ€è¦çš„ rs1
   - å¯ä»¥ç›´æ¥ä» `exec_bypass_data` è·å–ç»“æœï¼Œæ— éœ€ç­‰å¾…

2. **è®¿å­˜é˜¶æ®µæ—è·¯** (`mem_bypass_reg[0] == rs1`)

   - å¦‚æœä¸¤æ¡ä¹‹å‰çš„æŒ‡ä»¤çš„ç›®æ ‡å¯„å­˜å™¨æ˜¯æˆ‘ä»¬çš„ rs1
   - å¯ä»¥ä» `mem_bypass_data` è·å–

3. **ä¸éœ€è¦è¯¥æ“ä½œæ•°** (`~signals.rs1_valid`)

   - æŸäº›æŒ‡ä»¤ä¸ä½¿ç”¨ rs1ï¼ˆå¦‚ `lui`ã€`jal`ï¼‰
   - æ­¤æ—¶ä¸å­˜åœ¨å†’é™©

4. **å¯„å­˜å™¨æœªè¢«å ç”¨** (`(~(on_write >> rs1))[0:0]`)
   - å°† `on_write` å³ç§» rs1 ä½ï¼Œæ£€æŸ¥æœ€ä½ä½
   - å¦‚æœä¸º 0ï¼Œè¡¨ç¤ºè¯¥å¯„å­˜å™¨æ²¡æœ‰å¾…å†™å…¥çš„æ•°æ®

#### 1.3 ç­‰å¾…æ•°æ®å°±ç»ª

```python
valid = a_valid_true & b_valid_true & rd_valid_true

with Condition(~valid):
    log("pc: 0x{:08x} | rs1-x{:02}: {} | rs2-x{:02}: {} | rd-x{:02}: {} | backlogged",
        self.fetch_addr.peek(), rs1, a_valid, rs2, b_valid, rd, rd_valid)

wait_until(valid)  # å…³é”®ï¼šé˜»å¡ç›´åˆ°æ‰€æœ‰æ“ä½œæ•°å¯ç”¨
```

**`wait_until(valid)` çš„ç¡¬ä»¶å«ä¹‰**ï¼š

- è¿™ä¸æ˜¯è½¯ä»¶å±‚é¢çš„ç­‰å¾…ï¼Œè€Œæ˜¯ç”Ÿæˆç¡¬ä»¶æµæ°´çº¿æš‚åœé€»è¾‘
- å½“ `valid` ä¸º 0 æ—¶ï¼Œæ‰§è¡Œé˜¶æ®µä¿æŒå½“å‰çŠ¶æ€ï¼Œä¸æ¥å—æ–°æŒ‡ä»¤
- å‰çº§æµæ°´çº¿ï¼ˆè¯‘ç ï¼‰ä¹Ÿä¼šè¢«é˜»å¡
- ä¸€æ—¦ `valid` å˜ä¸º 1ï¼Œæµæ°´çº¿æ¢å¤è¿è¡Œ

---

### ç¬¬äºŒæ­¥ï¼šæ“ä½œæ•°è·å–

ä¸€æ—¦ç¡®è®¤æ•°æ®å¯ç”¨ï¼Œå°±éœ€è¦ä»æ­£ç¡®çš„æ¥æºè·å–æ“ä½œæ•°å€¼ã€‚

#### 2.1 æ—è·¯é€‰æ‹©å‡½æ•°

```python
def bypass(bypass_reg, bypass_data, idx, value):
    """
    æ—è·¯é€‰æ‹©å™¨
    - å¦‚æœ bypass_reg ä¸­è®°å½•çš„å¯„å­˜å™¨å·ç­‰äº idxï¼Œè¿”å› bypass_data
    - å¦åˆ™è¿”å›åŸå§‹ value
    """
    return (bypass_reg[0] == idx).select(bypass_data[0], value)
```

#### 2.2 è·å–æ“ä½œæ•° A (rs1)

```python
# ä¼˜å…ˆçº§ï¼šmem_bypass > exec_bypass > reg_file
a = bypass(mem_bypass_reg, mem_bypass_data, rs1, rf[rs1])  # å…ˆå°è¯•è®¿å­˜æ—è·¯
a = bypass(exec_bypass_reg, exec_bypass_data, rs1, a)       # å†å°è¯•æ‰§è¡Œæ—è·¯
a = (rs1 == Bits(5)(0)).select(Bits(32)(0), a)              # x0 æ’ä¸º 0
a = signals.csr_write.select(Bits(32)(0), a)                # CSR å†™æŒ‡ä»¤ç‰¹æ®Šå¤„ç†
a = (~a_valid).select(wb_bypass_data[0], a)                 # æœ€åå°è¯•å†™å›æ—è·¯
```

**æ—è·¯ä¼˜å…ˆçº§å›¾ç¤º**ï¼š

```
                    â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
                    â”‚              æ—è·¯æ•°æ®æ¥æº                â”‚
                    â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
                                        â”‚
        â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
        â”‚                               â”‚                               â”‚
        â–¼                               â–¼                               â–¼
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”               â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”               â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚  exec_bypass  â”‚  ä¼˜å…ˆçº§æœ€é«˜   â”‚  mem_bypass   â”‚   ä¼˜å…ˆçº§ä¸­    â”‚  wb_bypass    â”‚  ä¼˜å…ˆçº§æœ€ä½
â”‚   (E+1 å‘¨æœŸ)  â”‚â—„â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”‚   (E+2 å‘¨æœŸ)  â”‚â—„â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”‚   (E+3 å‘¨æœŸ)  â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜               â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜               â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
        â”‚                               â”‚                               â”‚
        â”‚                               â”‚                               â”‚
        â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
                                        â”‚
                                        â–¼
                                â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
                                â”‚   reg_file    â”‚  æœ€åé€‰æ‹©
                                â”‚   (å·²æäº¤)    â”‚
                                â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
```

#### 2.3 è·å–æ“ä½œæ•° B (rs2 æˆ– ç«‹å³æ•°)

```python
b = bypass(mem_bypass_reg, mem_bypass_data, rs2, rf[rs2])
b = bypass(exec_bypass_reg, exec_bypass_data, rs2, b)
b = (rs2 == Bits(5)(0)).select(Bits(32)(0), b)
b = is_csr.select(csr_f[csr_id], b)  # CSR æŒ‡ä»¤è¯»å– CSR å€¼
b = (~b_valid).select(wb_bypass_data[0], b)
```

#### 2.4 ç¡®å®š ALU è¾“å…¥

```python
# ALU æ“ä½œæ•° A
alu_a = (signals.is_offset_br | signals.is_pc_calc).select(fetch_addr, a)
#       â”‚                                                      â”‚       â”‚
#       â”‚ å¦‚æœæ˜¯ PC ç›¸å¯¹è·³è½¬(jal/bxx) æˆ– auipc                 â”‚ PC    â”‚ rs1 å€¼
#       â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”´â”€â”€â”€â”€â”€â”€â”€â”˜

# ALU æ“ä½œæ•° B
alu_b = signals.imm_valid.select(signals.imm, b)
#       â”‚                           â”‚           â”‚
#       â”‚ å¦‚æœæœ‰ç«‹å³æ•°              â”‚ ç«‹å³æ•°    â”‚ rs2 å€¼
#       â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”´â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
```

**ä¸åŒæŒ‡ä»¤çš„æ“ä½œæ•°æ¥æº**ï¼š

| æŒ‡ä»¤ç±»å‹               | alu_a æ¥æº | alu_b æ¥æº     |
| ---------------------- | ---------- | -------------- |
| `add rd, rs1, rs2`     | rs1        | rs2            |
| `addi rd, rs1, imm`    | rs1        | imm (ç¬¦å·æ‰©å±•) |
| `beq rs1, rs2, offset` | PC         | offset         |
| `jal rd, offset`       | PC         | offset         |
| `auipc rd, imm`        | PC         | imm << 12      |
| `lui rd, imm`          | 0          | imm << 12      |

---

### ç¬¬ä¸‰æ­¥ï¼šALU è¿ç®—

ALUï¼ˆç®—æœ¯é€»è¾‘å•å…ƒï¼‰æ‰§è¡Œå®é™…çš„è®¡ç®—æ“ä½œã€‚

#### 3.1 è®¡ç®—æ‰€æœ‰å¯èƒ½çš„ç»“æœ

```python
results = [Bits(32)(0)] * RV32I_ALU.CNT  # 16 ä¸ªç»“æœæ§½ä½

# åŠ æ³•
adder_result = (alu_a.bitcast(Int(32)) + alu_b.bitcast(Int(32))).bitcast(Bits(32))

# å‡æ³•
sub_result = (a.bitcast(Int(32)) - b.bitcast(Int(32))).bitcast(Bits(32))

# æ¯”è¾ƒï¼ˆæœ‰ç¬¦å·å°äºï¼‰
le_result = (a.bitcast(Int(32)) < b.bitcast(Int(32))).select(Bits(32)(1), Bits(32)(0))

# æ¯”è¾ƒï¼ˆç›¸ç­‰ï¼‰
eq_result = (a == b).select(Bits(32)(1), Bits(32)(0))

# æ¯”è¾ƒï¼ˆæ— ç¬¦å·å°äºï¼‰
leu_result = (a < b).select(Bits(32)(1), Bits(32)(0))

# ç®—æœ¯å³ç§»ï¼ˆä¿æŒç¬¦å·ä½ï¼‰
sra_signed_result = (a.bitcast(Int(32)) >> alu_b[0:4].bitcast(Int(5))).bitcast(Bits(32))

# å¡«å……ç»“æœæ•°ç»„
results[RV32I_ALU.ALU_ADD] = adder_result      # åŠ æ³•
results[RV32I_ALU.ALU_SUB] = sub_result        # å‡æ³•
results[RV32I_ALU.ALU_CMP_LT] = le_result      # æœ‰ç¬¦å·æ¯”è¾ƒ
results[RV32I_ALU.ALU_CMP_EQ] = eq_result      # ç›¸ç­‰æ¯”è¾ƒ
results[RV32I_ALU.ALU_CMP_LTU] = leu_result    # æ— ç¬¦å·æ¯”è¾ƒ
results[RV32I_ALU.ALU_XOR] = a ^ alu_b         # å¼‚æˆ–
results[RV32I_ALU.ALU_OR] = a | b              # æˆ–
results[RV32I_ALU.ALU_ORI] = a | alu_b         # æˆ–ç«‹å³æ•°
results[RV32I_ALU.ALU_AND] = a & alu_b         # ä¸
results[RV32I_ALU.ALU_TRUE] = Bits(32)(1)      # æ’çœŸï¼ˆç”¨äºæ— æ¡ä»¶è·³è½¬ï¼‰
results[RV32I_ALU.ALU_SLL] = a << alu_b[0:4]   # é€»è¾‘å·¦ç§»
results[RV32I_ALU.ALU_SRA] = sra_signed_result # ç®—æœ¯å³ç§»
results[RV32I_ALU.ALU_SRA_U] = a >> alu_b[0:4] # é€»è¾‘å³ç§»
results[RV32I_ALU.ALU_NONE] = Bits(32)(0)      # æ— æ“ä½œ
```

#### 3.2 é€‰æ‹©æ­£ç¡®çš„ç»“æœ

```python
alu = signals.alu  # æ¥è‡ªè¯‘ç å™¨çš„ ALU æ“ä½œç‹¬çƒ­ç 
result = alu.select1hot(*results)
```

**`select1hot` å·¥ä½œåŸç†**ï¼š

```
alu (ç‹¬çƒ­ç ):     0000 0000 0000 0001  (è¡¨ç¤º ALU_ADD)
                                    â”‚
results[0]:  â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”€â–¶ è¾“å‡º
results[1]:  â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€ â”‚ â”€â”€â”€â”€â”€â”€
results[2]:  â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€ â”‚ â”€â”€â”€â”€â”€â”€
...                                  â”‚
results[15]: â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€ â”‚ â”€â”€â”€â”€â”€â”€
                                     â”‚
                               â”Œâ”€â”€â”€â”€â”€â”´â”€â”€â”€â”€â”€â”
                               â”‚ select1hotâ”‚
                               â””â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”˜
                                     â”‚
                                     â–¼
                                  result
```

---

### ç¬¬å››æ­¥ï¼šåˆ†æ”¯å¤„ç†

åˆ†æ”¯æŒ‡ä»¤éœ€è¦åˆ¤æ–­æ¡ä»¶å¹¶è®¡ç®—ç›®æ ‡åœ°å€ã€‚

#### 4.1 æ¡ä»¶åˆ¤æ–­

```python
# ç”¨ select1hot æ ¹æ® cond é€‰æ‹©æ¯”è¾ƒç»“æœ
condition = signals.cond.select1hot(*results)

# å¤„ç†æ¡ä»¶ç¿»è½¬ï¼ˆç”¨äº bne, bge ç­‰ï¼‰
condition = signals.flip.select(~condition, condition)
```

**æ¡ä»¶ç¿»è½¬ç¤ºä¾‹**ï¼š

- `beq`: ä½¿ç”¨ `ALU_CMP_EQ`ï¼Œ`flip=0`ï¼Œæ¡ä»¶ä¸º `a == b`
- `bne`: ä½¿ç”¨ `ALU_CMP_EQ`ï¼Œ`flip=1`ï¼Œæ¡ä»¶ä¸º `!(a == b)` = `a != b`
- `blt`: ä½¿ç”¨ `ALU_CMP_LT`ï¼Œ`flip=0`ï¼Œæ¡ä»¶ä¸º `a < b`
- `bge`: ä½¿ç”¨ `ALU_CMP_LT`ï¼Œ`flip=1`ï¼Œæ¡ä»¶ä¸º `!(a < b)` = `a >= b`

#### 4.2 è®¡ç®—ä¸‹ä¸€æ¡æŒ‡ä»¤åœ°å€

```python
pc0 = (fetch_addr.bitcast(Int(32)) + Int(32)(4)).bitcast(Bits(32))  # PC + 4
```

#### 4.3 ç¡®å®šåˆ†æ”¯ç›®æ ‡

```python
with Condition(signals.is_branch):
    # å¦‚æœæ¡ä»¶ä¸ºçœŸï¼Œè·³è½¬åˆ° resultï¼ˆè®¡ç®—å‡ºçš„ç›®æ ‡åœ°å€ï¼‰
    # å¦åˆ™ç»§ç»­æ‰§è¡Œ pc0ï¼ˆPC + 4ï¼‰
    exec_br_dest[0] = condition[0:0].select(result, pc0)
    log("condition: {}.a.b | a: {:08x} | b: {:08x}", condition[0:0], result, pc0)

# è®°å½•æ˜¯å¦å‘ç”Ÿäº†è·³è½¬
exec_br_jump = signals.is_branch.select(condition[0:0], Bits(1)(0))
```

---

### ç¬¬äº”æ­¥ï¼šè®¾ç½®æ—è·¯ä¸è®¿å­˜è¯·æ±‚

#### 5.1 è®¾ç½®æ‰§è¡Œé˜¶æ®µæ—è·¯

```python
# åªæœ‰éè®¿å­˜æŒ‡ä»¤ä¸”ç›®æ ‡å¯„å­˜å™¨é x0 æ‰äº§ç”Ÿæ—è·¯
produced_by_exec = ~memory_read & (rd != Bits(5)(0))

exec_bypass_reg[0] = produced_by_exec.select(rd, Bits(5)(0))
exec_bypass_data[0] = produced_by_exec.select(result, Bits(32)(0))
```

**ä¸ºä»€ä¹ˆè®¿å­˜æŒ‡ä»¤ä¸è®¾ç½®æ‰§è¡Œæ—è·¯ï¼Ÿ**

- `lw` æŒ‡ä»¤çš„ç»“æœè¦åˆ°è®¿å­˜é˜¶æ®µæ‰èƒ½è·å¾—
- æ­¤æ—¶ `result` åªæ˜¯åœ°å€ï¼Œä¸æ˜¯å®é™…æ•°æ®
- è®¿å­˜é˜¶æ®µä¼šè®¾ç½® `mem_bypass`

#### 5.2 å‘èµ·è®¿å­˜è¯·æ±‚

```python
memory_read = signals.memory[0:0]   # æ˜¯å¦è¯»å†…å­˜
memory_write = signals.memory[1:1]  # æ˜¯å¦å†™å†…å­˜

is_memory = memory_read | memory_write

# è®¡ç®—å†…å­˜åœ°å€ï¼ˆå‡å»åç§»é‡è½¬æ¢ä¸ºç›¸å¯¹åœ°å€ï¼‰
addr = (result.bitcast(UInt(32)) -
        is_memory.select(offset_reg[0].bitcast(UInt(32)), UInt(32)(0))).bitcast(Bits(32))

# æå–è¡Œåœ°å€ï¼ˆå­—å¯¹é½ï¼‰
request_addr = is_memory.select(addr[2:2+depth_log-1].bitcast(UInt(depth_log)), UInt(depth_log)(0))

# åˆ›å»ºå¹¶è®¿é—® D-Cache
dcache = SRAM(width=32, depth=1<<depth_log, init_file=data)
dcache.name = 'dcache'
dcache.build(we=memory_write, re=memory_read, wdata=b, addr=request_addr)
```

#### 5.3 è°ƒç”¨è®¿å­˜æ¨¡å—

```python
bound = memory.bind(
    rd=rd,
    result=signals.link_pc.select(pc0, result),  # jal/jalr é“¾æ¥ PC+4
    mem_ext=signals.mem_ext,
    is_mem_read=memory_read
)
bound.async_called()
```

---

## ğŸ” ç‰¹æ®ŠæŒ‡ä»¤å¤„ç†

### ebreak/ecall æŒ‡ä»¤

```python
is_ebreak = signals.rs1_valid & signals.imm_valid & \
            ((signals.imm == Bits(32)(1)) | (signals.imm == Bits(32)(0))) & \
            (signals.alu == Bits(16)(1<<RV32I_ALU.ALU_NONE))

with Condition(is_ebreak):
    log('ebreak | halt | ecall')
    finish()  # ç»ˆæ­¢ä»¿çœŸ
```

### CSR æŒ‡ä»¤

```python
# CSR å¯„å­˜å™¨åœ°å€æ˜ å°„
raw_id = [
    (773, 1),   # mtvec
    (833, 2),   # mepc
    (772, 4),   # mie
    (768, 8),   # mstatus
    ...
]

# æ ¹æ®ç«‹å³æ•°ç¡®å®š CSR ID
for i, j in raw_id:
    csr_id = (signals.imm[0:11] == Bits(12)(i)).select(Bits(4)(j), csr_id)

# CSR å†™å…¥
with Condition(signals.csr_write):
    csr_f[csr_id] = csr_new
```

---

## ğŸ“Š æ‰§è¡Œé˜¶æ®µæ—¶åºå›¾

```
æ—¶é’Ÿå‘¨æœŸ:     â”‚ T   â”‚ T+1 â”‚ T+2 â”‚ T+3 â”‚
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€
æ•°æ®å†’é™©æ£€æµ‹  â”‚ â–ˆâ–ˆâ–ˆ â”‚     â”‚     â”‚     â”‚
æ“ä½œæ•°è·å–    â”‚     â”‚ â–ˆâ–ˆâ–ˆ â”‚     â”‚     â”‚
ALU è¿ç®—     â”‚     â”‚     â”‚ â–ˆâ–ˆâ–ˆ â”‚     â”‚
ç»“æœè¾“å‡º      â”‚     â”‚     â”‚     â”‚ â–ˆâ–ˆâ–ˆ â”‚
```

ï¼ˆæ³¨ï¼šå®é™…ä¸Šè¿™äº›éƒ½åœ¨åŒä¸€ä¸ªæ—¶é’Ÿå‘¨æœŸå†…å®Œæˆï¼Œä¸Šå›¾åªæ˜¯å±•ç¤ºé€»è¾‘é¡ºåºï¼‰

---

## âš ï¸ æ³¨æ„äº‹é¡¹

1. **æ—è·¯æ•°æ®çš„æ—¶æ•ˆæ€§**ï¼šæ—è·¯æ•°æ®åªåœ¨ç‰¹å®šå‘¨æœŸæœ‰æ•ˆï¼Œå¿…é¡»æ­£ç¡®åŒ¹é…
2. **x0 å¯„å­˜å™¨**ï¼šå§‹ç»ˆä¸º 0ï¼Œä¸èƒ½è¢«å†™å…¥
3. **åˆ†æ”¯å»¶è¿Ÿ**ï¼šåˆ†æ”¯ç›®æ ‡åœ¨æ‰§è¡Œé˜¶æ®µç¡®å®šï¼Œå–æŒ‡éœ€è¦ 1-2 å‘¨æœŸæ‰èƒ½å“åº”
4. **CSR åŸå­æ€§**ï¼šCSR è¯»å†™åœ¨åŒä¸€å‘¨æœŸå®Œæˆ

---

## ğŸ“ˆ æ€§èƒ½ä¼˜åŒ–ç‚¹

1. **æ—è·¯ç½‘ç»œ**ï¼šé¿å…äº†å¤§éƒ¨åˆ†æ•°æ®å†’é™©å¯¼è‡´çš„æµæ°´çº¿æš‚åœ
2. **å¹¶è¡Œè®¡ç®—**ï¼šæ‰€æœ‰ ALU æ“ä½œåŒæ—¶è®¡ç®—ï¼Œç”¨é€‰æ‹©å™¨é€‰å–ç»“æœ
3. **æ—©æœŸåˆ†æ”¯åˆ¤æ–­**ï¼šåˆ†æ”¯ç›®æ ‡åœ¨ E é˜¶æ®µå°±ç¡®å®šï¼Œå‡å°‘åˆ†æ”¯å»¶è¿Ÿ
