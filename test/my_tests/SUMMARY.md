# 工作总结

## 1. 编译环境调整
为了满足“不要开启优化”的要求，我们将编译选项从 `-O3` 调整为 `-O0`。这导致了以下变化和所需的修复：

*   **堆栈初始化 (`start.S`)**: `-O0` 编译的代码大量使用堆栈（保存局部变量、函数调用帧）。默认的链接器脚本或启动代码可能未正确设置堆栈指针 (`sp`)。我们创建了 `start.S`，将 `sp` 初始化为 `0x10000`，并跳转到 `main` 函数。
*   **软件乘法 (`__mulsi3`)**: 在 RV32I 指令集下（无硬件乘法器），`-O0` 导致编译器生成对 `__mulsi3` 函数的调用来处理乘法，而不是优化为移位或常量。我们在 `matrix.c` 中曾手动添加此函数（现已删除 `matrix` 测试）。
*   **加载脚本 (`loader.py`)**: 修正了 `loader.py` 的参数传递方式，使其能正确处理输入输出路径。

## 2. 测试用例状态
*   **Fibonacci (`fib`)**: **通过**。计算 Fib(10) = 55。
*   **Sort (`sort`)**: **失败**。预期结果 15 (数组和)，实际结果 0。这可能是由于数组初始化或复杂的内存访问模式在当前仿真器中存在问题。
*   **Matrix (`matrix`)**: **已删除**。因当前 CPU 不支持乘法指令，且用户要求删除。

## 3. Fibonacci 代码解析 (`fib.exe`)
以下是 `fib.c` 在 `-O0` 优化下生成的汇编代码分析。

### 源代码 (`fib.c`)
```c
int main() {
    int n = 10;
    int a = 0, b = 1, c, i;
    // ... loop ...
    asm volatile ("mv a0, %0" ...);
}
```

### 汇编分析 (`fib.exe` / `fib.riscv`)
由于未开启优化，编译器将所有局部变量存储在堆栈上，而不是寄存器中。

1.  **启动 (`_start`)**:
    ```assembly
    lui sp, 0x10      ; sp = 0x10000 (设置堆栈顶)
    call main         ; 调用 main 函数
    ebreak            ; 结束
    ```

2.  **函数序言 (`main`)**:
    ```assembly
    addi sp, sp, -48  ; 分配 48 字节的栈帧
    sw s0, 44(sp)     ; 保存旧的帧指针
    addi s0, sp, 48   ; 设置新的帧指针 (s0 指向栈帧底部)
    ```

3.  **变量初始化**:
    ```assembly
    li a5, 10
    sw a5, -36(s0)    ; n = 10 (存储在栈上偏移 -36)
    sw zero, -20(s0)  ; a = 0  (存储在栈上偏移 -20)
    li a5, 1
    sw a5, -24(s0)    ; b = 1  (存储在栈上偏移 -24)
    ```
    可以看到，每个变量赋值都对应一次 `sw`（存储）操作。

4.  **循环逻辑**:
    ```assembly
    lw a5, -36(s0)    ; 加载 n
    bnez a5, ...      ; 检查 n != 0
    ...
    lw a4, -32(s0)    ; 加载 i
    lw a5, -36(s0)    ; 加载 n
    bge a5, a4, ...   ; 如果 n >= i，继续循环
    ```
    每次使用变量（如 `i` 或 `n`）进行比较或计算时，都会从堆栈中 `lw`（加载），计算完后再 `sw`（存储）回堆栈。这就是 `-O0` 的特征：不做寄存器分配优化，确保每一行 C 代码的执行都反映在内存状态上。

5.  **结果输出**:
    ```assembly
    lw a5, -28(s0)    ; 加载 c
    mv a0, a5         ; 将 c 放入 a0 (x10) 作为返回值
    ebreak
    ```

这种代码虽然效率低（大量的内存访问），但非常适合验证 CPU 的基本功能（加载、存储、分支、算术运算）以及流水线的正确性，因为它避免了编译器将复杂逻辑优化为简单的常量加载。
